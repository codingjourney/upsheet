#!/usr/bin/python
import base64
import getpass
import json
import pycurl
import re
import StringIO
import sys

# Parses a timesheet file and creates work log entries in a JIRA instance.
# The expected format of the timesheet file is:
#
# YYYYmmdd
#   HHMM-HHMM issueID: comment
#   HHMM-HHMM issueID: comment
#   ...
#
# where YYYY = year, mm = month, dd = day, HH = hour, MM = minute,
#       issueID = JIRA issue ID, comment = single-line work log comment

# Configuration
URL  = "http://localhost:8080/rest/api/latest/issue/%s%s"
USER = "admin"
PASS = "" # if empty, user will be prompted for password
TYPE = "Content-Type: application/json"
AUTH = "Authorization: Basic %s"
TIME = "%s-%s-%sT%s:%s:00.000+0200"

# Line format patterns
DATE_LINE = re.compile("^\d{8}$")
TIME_LINE = re.compile("^  (\d{4})-(\d{4}) ([A-Z]+-[0-9]+): +(\S.+)$")

# Work log cache for collision detection
# format: {issueID:[(startTime,endTime),...],...} with YYmmddHHMM timestamps
knownWorkLogs = {}

# Exception class for carrying HTTP details up the stack
class ResponseException:
  def __init__(self, url, dataSent, httpStatus, message, response):
    self.url = url; self.dataSent = dataSent; self.httpStatus = httpStatus
    self.message = message; self.response = response
  def __str__(self):
    return "\nError accessing %s\nData sent: %s\n%s\n\n%s"\
           % (self.url, str(self.dataSent), self.message, self.response)

def timestamp(date, time):
  year   = date[:4]
  month  = date[4:6]
  day    = date[6:]
  hour   = time[:2]
  minute = time[2:]
  return TIME % (year, month, day, hour, minute)

def parseTimestamp(ts):
  date = ts[0:4] + ts[5:7] + ts[8:10]
  time = ts[11:13] + ts[14:16]
  return date, time

def duration(startTime, endTime):
  startH = int(startTime[:2])
  startM = int(startTime[2:])
  endH   = int(endTime[:2])
  endM   = int(endTime[2:])
  if endH < startH: endH += 24
  start = 60 * startH + startM
  end   = 60 * endH + endM
  return end - start

def askServer(issueID, pathOrQuery, credentials, body):
  url  = URL  % (issueID, pathOrQuery)
  auth = AUTH % credentials
  head = StringIO.StringIO()
  buff = StringIO.StringIO()
  c = pycurl.Curl()
  try:
    c.setopt(c.URL, url)
    c.setopt(c.HTTPHEADER, [TYPE, auth])
    if body != None:
      c.setopt(c.POSTFIELDS, json.dumps(body))
    c.setopt(c.WRITEFUNCTION, buff.write)
    c.setopt(c.HEADERFUNCTION, head.write)
    c.perform()
    httpStatus = c.getinfo(c.HTTP_CODE)
    response, message = parseResponse(httpStatus, head, buff)
    if message != None:
      raise ResponseException(url, body, httpStatus, message, response)
    else:
      return response
  finally:
    c.close()

def parseResponse(httpStatus, head, buff):
  message = None
  response = None
  if httpStatus not in (200, 201):
    message = "HTTP response not OK"
    response = head.getvalue()
  else:
    try:
      response = json.loads(buff.getvalue())
    except:
      message = "Failed to parse response"
      response = buff.getvalue()
    if type(response) is dict and "errors" in response:
      message = "Response claims errors"
      response = response["errors"]
  return response, message

def status(issueID):
  response = askServer(issueID, "?fields=status", credentials, None)
  return response["fields"]["status"]["name"]

def workLog(issueID):
  if issueID in knownWorkLogs:
    workLog = knownWorkLogs[issueID]
  else:
    workLog = downloadWorkLog(issueID)
    knownWorkLogs[issueID] = workLog
  return workLog

def downloadWorkLog(issueID):
  fullLog = askServer(issueID, "/worklog", credentials, None)
  workLog = []
  for entry in fullLog["worklogs"]:
    if entry["author"]["name"] == USER:
      date, startTime = parseTimestamp(entry["started"])
      duration = entry["timeSpentSeconds"] / 60
      workLog.append(newEntry(date, startTime, duration))
  return workLog

def newEntry(date, startTime, duration):
  startH = int(startTime[:2])
  startM = int(startTime[2:])
  endTimeRaw = startH * 60 + startM + duration
  endH = str(endTimeRaw / 60).rjust(2, "0")
  endM = str(endTimeRaw % 60).rjust(2, "0")
  return (date + startTime, date + endH + endM)

def collides(issueID, date, startTime, endTime):
  startHour = int(startTime[:2])
  endHour   = int(endTime[:2])
  if endHour < startHour:
    endTime = str(endHour + 24) + endTime[2:]
  interval = date + startTime, date + endTime
  for entry in workLog(issueID):
    if entry[0] < interval[1] and entry[1] > interval[0]:
      return True
  return False

def upload(credentials, date, start, end, issueID, comment):
  when = timestamp(date, start)
  mins = duration(start, end)
  body = {"comment" : comment, "started" : when, "timeSpent" : str(mins) + "m"}
  askServer(issueID, "/worklog", credentials, body)
  workLog(issueID).append(newEntry(date, start, mins))

def process(path, credentials):
  f = open(path)
  date = ""
  for lineWithNewline in f:
    line = lineWithNewline[:-1]
    if DATE_LINE.match(line):
      date = line
    else:
      match = TIME_LINE.match(line)
      if match != None:
        startTime = match.group(1)
        endTime   = match.group(2)
        issueID   = match.group(3)
        comment   = match.group(4)
        try:
          if collides(issueID, date, startTime, endTime):
            print(" Collision: " + date + line)
          else:
            upload(credentials, date, startTime, endTime, issueID, comment)
            print("  Uploaded: " + date + line)
        except ResponseException as rx:
          if rx.httpStatus == 400 and status(issueID) == "Closed":
            print("Was closed: " + date + line)
          elif rx.httpStatus == 404:
            print("No such ID: " + date + line)
          else:
            print(str(rx))
            sys.exit(1)
      elif len(line) > 0:
        print("Bad format: " + line)


if len(sys.argv) >= 2:
  password = PASS
  if len(password) == 0:
    password = getpass.getpass("Password: ")
  credentials = base64.b64encode("%s:%s" % (USER, password))
  process(sys.argv[1], credentials)
else:
  print("USAGE: %s /path/to/timesheet" % sys.argv[0])
